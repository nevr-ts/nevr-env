/**
 * `nevr generate` command
 *
 * Generate .env.example from the schema
 */

import { Command } from "commander";
import * as p from "@clack/prompts";
import pc from "picocolors";
import { existsSync, writeFileSync } from "fs";
import { join } from "path";
import {
  findConfigFile,
  loadConfigFile,
  extractSchemaFromConfig,
} from "../utils/config";

interface GenerateOptions {
  cwd: string;
  config?: string;
  output?: string;
  force?: boolean;
}

async function generateAction(opts: GenerateOptions) {
  const cwd = opts.cwd || process.cwd();

  console.log("");
  p.intro(pc.bgYellow(pc.black(" ğŸ“„ nevr-env generate ")));

  // Find config file
  const configPath = opts.config || findConfigFile(cwd);

  if (!configPath) {
    p.log.error("No configuration file found. Run `npx nevr-env init` first.");
    process.exit(1);
  }

  p.log.info(`Using config: ${pc.dim(configPath)}`);

  // Load config
  const s = p.spinner();
  s.start("Loading configuration...");

  let config: unknown;
  try {
    config = await loadConfigFile(configPath, { cwd });
  } catch (error) {
    s.stop("Failed to load configuration");
    p.log.error(String(error));
    process.exit(1);
  }

  s.stop("Configuration loaded");

  // Extract schema via metadata registry
  const schema = extractSchemaFromConfig(config);

  // Build variables map with metadata for .env.example
  const variables = new Map<string, { plugin?: string; description?: string; example?: string }>();

  // Plugin variables (include CLI prompt info)
  for (const [key, plugin] of schema.pluginInfo) {
    const promptConfig = plugin.cli?.prompts?.[key];
    variables.set(key, {
      plugin: plugin.name,
      description: promptConfig?.message,
      example: promptConfig?.placeholder,
    });
  }

  // Server/client/shared variables not already from plugins
  for (const [section, sectionName] of [
    ["server", "Server"],
    ["client", "Client"],
    ["shared", "Shared"],
  ] as const) {
    const keys = section === "server" ? schema.serverKeys
               : section === "client" ? schema.clientKeys
               : schema.sharedKeys;
    for (const key of keys) {
      if (!variables.has(key)) {
        variables.set(key, {
          description: `${sectionName} variable`,
        });
      }
    }
  }

  if (variables.size === 0) {
    p.log.warn("No environment variables found in configuration.");
    process.exit(0);
  }

  // Generate .env.example content
  const lines: string[] = [
    "# Environment Variables",
    "# Generated by nevr-env",
    "#",
    "# Copy this file to .env and fill in the values",
    "# Or run `npx nevr-env fix` for interactive setup",
    "",
  ];

  // Group by plugin
  const byPlugin = new Map<string, Array<[string, { plugin?: string; description?: string; example?: string }]>>();

  for (const [key, info] of variables) {
    const group = info.plugin || "Custom";
    if (!byPlugin.has(group)) {
      byPlugin.set(group, []);
    }
    byPlugin.get(group)!.push([key, info]);
  }

  for (const [group, vars] of byPlugin) {
    lines.push(`# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
    lines.push(`# ${group}`);
    lines.push(`# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
    lines.push("");

    for (const [key, info] of vars) {
      if (info.description) {
        lines.push(`# ${info.description}`);
      }
      if (info.example) {
        lines.push(`# Example: ${info.example}`);
      }
      lines.push(`${key}=`);
      lines.push("");
    }
  }

  // Determine output path
  const outputPath = opts.output || join(cwd, ".env.example");

  // Check if file exists â€” skip prompt in non-TTY or when --force is set
  if (existsSync(outputPath) && !opts.force && process.stdout.isTTY) {
    const overwrite = await p.confirm({
      message: `${outputPath} already exists. Overwrite?`,
      initialValue: false,
    });

    if (p.isCancel(overwrite) || !overwrite) {
      p.cancel("Generation cancelled");
      process.exit(0);
    }
  }

  // Write file
  writeFileSync(outputPath, lines.join("\n"), "utf-8");

  p.log.success(`Generated ${pc.cyan(outputPath)}`);
  p.log.info(`Found ${pc.bold(variables.size)} variable(s)`);

  p.outro(pc.green("âœ… .env.example generated successfully!"));
}

export const generate = new Command("generate")
  .description("Generate .env.example from the schema")
  .option("--cwd <path>", "Working directory", process.cwd())
  .option("-c, --config <path>", "Path to config file")
  .option("-o, --output <path>", "Output file path")
  .option("-f, --force", "Overwrite output file without prompting", false)
  .action(generateAction);

export default generate;
